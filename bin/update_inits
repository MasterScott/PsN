#!/usr/bin/perl

# Only for Development
use FindBin qw($Bin);
use lib "$Bin/../lib";

# Don't edit the line below, it must look exactly like this.
# Everything above this line will be replaced #

use PsN;
use model;
use output;
use Getopt::Long;
use File::Copy qw/cp mv/;
use common_options;

sub search_record {
  #input is string $row and array ref $list
  #$row has no leading spaces nor $ 
  my $row = shift;
  my $reclist=shift;
  my $found = 0;

  foreach my $rec (@{$reclist}){
    if ($row =~ /^($rec)/){
      $found = $rec;
      last;
    }
  }
  return $found;

}



if ($ARGV[0] && (($ARGV[0] eq '-h') || ($ARGV[0] eq '-help'))){
  print <<'ENDHELP';

update_inits
    Update NONMEM modelfile initial estimates of theta, omega and sigma
    using final estimates from lst-file or initial estimates from other modelfile.
    Only works when single problem in modelfile.

Example: (modify file old.mod and copy original to old.mod.org):    
    update_inits old.mod old.lst

OR (create new file new.mod):
    update_inits old.mod old_output.lst -output_model=new.mod

OR (assume there exists an lst-file with name myModel.lst ):
    update_inits myModel.mod -output_model=new.mod

OR (copy estimates from modelfile instead of lst-file, modify old.mod):
    update_inits old.mod -from_model=other.mod

Required input: The name of a modelfile.

Optional input: 
<lst-filename>              The name of the lst-file to read final estimates from.
                            Cannot be used together with option -from_model.

-from_model=<filename>      The name of the modelfile to copy initials from. 
                            Cannot be used together with lst-file input.

-output_model=<filename>    The name of the modelfile to create. If omitted, a copy of
                            the original modelfile with extension .org is created, and 
                            the original file is modified.

-ignore_missing_parameters  Do not require 1-1 matching of parameter names and indexes.

-sigdig=N                   Only has effect with NONMEM7 and later and if N<15. Print parameter
                            estimates with this many significant digits in the new model file.

-renumber=<new number>      All words in $TABLE records that end with tab<any number> 
                            or tab<any number>.csv will get <any number> replaced 
							by <new number>, provided that <new number> is not 0.
							If <filename> in MSFO=<filename> in the  $ESTIMATION record
							ends with a number, that number will be replaced by <new number>.
							MSFO may not be abbreviated.
							If the input modelfile name is runX.mod and -output_model is runY.mod
							where both X and Y are numbers then -renumber=Y will be set automatically.
							Set option -renumber=0 to prevent renumbering in such a case.

-comment=<comment>          If the option is used, a new line with <comment> will be inserted 
                            directly following the $PROBLEM row.
							The comment must be enclosed with quotes if it contains spaces.

-add_tags                   Add all runrecord tags. update_inits will not check if any tags 
                            are already present.

-degree=X                   After updating the initial estimates in the output file, randomly
                            perturb them by degree=X, i.e. change estimate to a value
							randomly chosen in the range estimate +/- estimate*X while
							respecting upper and lower boundaries, if set.
							Degree is set to 0.1 when tweak_inits is set in execute.

-based_on=<run_number>      If the Based on tag is present in the modelfile, or if option 
                            -add_tags is used, update_inits will by default try to extract 
							a run number from the original modelfile name and set the 
							Based on tag for runrecord to that number. If a number cannot 
							be extracted then nothing will be set. If the -based_on option 
							is used, update_inits will set the tag to that number.

-add_prior=df               Add $PRIOR NWPRI based on output object. Will automatically read
                            estimates and covariances from output and use them to define the 
							prior. df should be the degrees of freedom, a comma-separated list
							with one integer per omega block.
							This feature is highly experimental, and you must check $PRIOR 
							in the new model file manually before using it.
							Option -add_prior cannot be used together with option -from_model. 

-diagonal_dominance         By default not set. If option is set then PsN will ensure that OMEGA
                            and SIGMA are strictly diagonally dominant by decreasing off-diagonal
							elements if necessary. This in turn guarantees that OMEGA and SIGMA 
							are positive definite. NONMEM sometimes prints OMEGA or SIGMA matrices
							in the lst-file which are not positive definite, and the 
							diagonal_dominance option offers a convenient way to fix this. However, 
							the perturbation made my PsN is most likely not the smallest perturbation 
							required to make OMEGA/SIGMA positive definite.

ENDHELP
exit;
} 


my %options;

my %optional_options = ( "output_model:s" => undef,
						 "from_model:s" => undef,
						 "ignore_missing_parameters" => undef,
						 "comment:s" => undef,
						 "degree:f" => undef,
						 "add_tags" => undef,
						 "diagonal_dominance" => undef,
						 "add_prior:s" => undef,
						 "seed:s" => undef,
						 "based_on:i" => undef,
						 "renumber:i" => undef,
						 "sigdig:i" => undef);

my $res = GetOptions( \%options,
					  keys(%optional_options) );
common_options::setup( \%options, 'update_inits' ); 

exit unless $res;


my $ignore_missing_parameters=0;
if ( defined $options{'ignore_missing_parameters'} ){
	$ignore_missing_parameters=1;
}


unless( $ARGV[0] ){
	die "You must at least enter a model file name\n";
}
my $run_number;
#extract run number
if ($ARGV[0]){
	my $tmp = $ARGV[0];
	if ($tmp =~ /(run|Run|RUN)([0-9]+[^0-9]*)\./){
		$run_number = $2;
	}  
}

unless( -e $ARGV[0] ){
	die "No such file: $ARGV[0]\n";
}


my $tablenum;
my $auto_renumber=0;
if (defined $options{'renumber'}) {
	$tablenum=$options{'renumber'} if ($options{'renumber'} != 0);
}elsif( $options{'output_model'} ){
	my $tmp = $options{'output_model'};
	if ($tmp =~ /(run|Run|RUN)([0-9]+)[^0-9]*\./){
		$tablenum = $2;
		$options{'renumber'}=$tablenum;
		$auto_renumber=1;
	}  
}

my @record_list=('THETA','OMEGA','SIGMA');
print "Updating records ".join(' ',@record_list)."\n";
print "and renumbering table and msfo files (set -renumber=0 to avoid this)\n" if ($auto_renumber);

if( $ARGV[1] && $options{'from_model'}){
	die "Ambiguous input: Cannot specify both lst-file and from_model.\n";
}

if( $options{'add_prior'})  {
	push(@record_list,'PRI');
	die "Cannot specify both -add_prior and -from_model.\n" if($options{'from_model'});
}



my $ignore_missing_files=1;
$ignore_missing_files = 0 unless ( $ARGV[1] );
my $model = model -> new ( filename => $ARGV[0],
						   ignore_missing_files => $ignore_missing_files,
						   skip_data_parsing => 1,
						   ignore_missing_data =>1);
my $model_copy = model -> new ( filename => $ARGV[0],
								ignore_missing_files => 1,
								skip_data_parsing => 1,
								ignore_missing_data=>1);

if ( scalar (@{$model-> problems}) != 1 ){
	die 'Script can only handle modelfiles with exactly one problem.\n';
}


my $outfile;

if ( $options{'output_model'} ){
	$outfile = $options{'output_model'};
}  else {
	#original file will be overwritten, copy to .org
	cp( $ARGV[0], $ARGV[0].'.org' );
	$outfile = $ARGV[0];
}

if (defined $options{'from_model'}) {
	die "No such file: ".$options{'from_model'}."\n" unless (-e $options{'from_model'});
	my $params_model = model -> new ( filename => $options{'from_model'},
									  ignore_missing_files => 1,
									  skip_data_parsing => 1,
									  ignore_missing_data=>1);

	my $array = $params_model->get_hash_values_to_labels();

	my $check = 0;
	$check = $options{'diagonal_dominance'} if (defined $options{'diagonal_dominance'});
	for (my $i=0; $i< scalar(@{$model_copy->problems}); $i++){
		last if ($i >= scalar(@{$array}));
		$model_copy -> update_inits( from_hash => $array->[$i],
									 problem_number => ($i+1),
									 ensure_diagonal_dominance => $check,
									 ignore_missing_parameters => $ignore_missing_parameters );
	}

} else { 
	my $output;
	if( $ARGV[1] ){
		$output = output -> new( filename => $ARGV[1],
								 ignore_missing_files => 0);

		unless( $output ){
			die "No such file: $ARGV[1]\n";
		}
		unless ($output->parsed_successfully()){
			die "Failed to parse $ARGV[1]: ".$output -> parsing_error_message();
		}
	}elsif( defined $model->outputs and -e $model ->outputs -> [0] -> filename ){
		$output = $model -> outputs -> [0];
		unless ($output->parsed_successfully()){
			die "Failed to parse ".$model ->outputs -> [0] -> filename.": ".
				$output -> parsing_error_message();
		}
	} else {
		die "No file to read parameter values from\n";
	}
#copy does not copy ignore_missing_files
#  my $model_copy = $model -> copy( filename => $tempfile,
#				   copy_data => 1);
	my $check = 0;
	$check = $options{'diagonal_dominance'} if (defined $options{'diagonal_dominance'});
	$model_copy -> update_inits( from_output => $output,
								 ensure_diagonal_dominance => $check,
								 ignore_missing_parameters => $ignore_missing_parameters );

}
$model_copy -> filename( $outfile );

if (defined $options{'degree'}){
	foreach my $prob ( @{$model_copy->problems()}) {
		$prob -> set_random_inits ( degree => $options{'degree'} );
	}
}

if ($options{'add_prior'}){
	$model_copy -> problems()->[0]->add_prior_distribution(from_output => $output,
														   problem_number => 1,
														   df_string => $options{'add_prior'});
}	


if (defined $options{'renumber'} and $options{'renumber'} != 0){
	for (my $j=0; $j< scalar(@{$model_copy->problems}); $j++){
		#handle table
		if (defined $model_copy->problems->[$j]->tables){
			foreach my $tab (@{$model_copy->problems->[$j]->tables}){
				$tab->renumber_file (numberstring => $tablenum);
			}
		}
		#handle estimation
		if (defined $model_copy->problems->[$j]->estimations){
			foreach my $est (@{$model_copy->problems->[$j]->estimations}){
				$est->renumber_msfo (numberstring => $tablenum);
			}
		}
	}
}	
#handle PROBLEM update_tags add_tags add_comment
my $based_on = $run_number;
$based_on = $options{'based_on'} if (defined $options{'based_on'});

if (defined $based_on or defined $options{'comment'} or defined $options{'add_tags'}){
	$model_copy->problems ->[0]->problems->[0]->update_runrecord_tags(based_on =>$based_on,
																	  new_comment =>$options{'comment'},
																	  add_tags => (defined $options{'add_tags'}));
}
$model_copy -> _write(number_format => $options{'sigdig'},
					  local_print_order => 1);







