#!/usr/bin/perl

# Only for Development
use FindBin qw($Bin);
use lib "$Bin/../lib";

# Don't edit the line below, it must look exactly like this.
# Everything above this line will be replaced #

use PsN;
use model;
use output;
use Getopt::Long;
use File::Copy qw/cp mv/;
use common_options;
use Math::Random;
use ui;

sub search_record {
  #input is string $row and array ref $list
  #$row has no leading spaces nor $ 
  my $row = shift;
  my $reclist=shift;
  my $found = 0;

  foreach my $rec (@{$reclist}){
    if ($row =~ /^($rec)/){
      $found = $rec;
      last;
    }
  }
  return $found;

}

my %options;
my %required_options =();
my %optional_options = (
    'h|?'                       => undef,
    'help'                      => undef,
	"output_model:s" => undef,
	"from_model:s" => undef,
	"ignore_missing_parameters" => undef,
	"update_fix" => undef,
	"comment:s" => undef,
	"degree:f" => undef,
	"add_tags" => undef,
	"flip_comments" => undef,
	"ensure_posdef" => undef,
	"add_prior:s" => undef,
	"seed:s" => undef,
	"nm_version:s" => undef,
	"based_on:i" => undef,
	"renumber:i" => undef,
	"fix_thetas" => undef,
 	"unfix_thetas" => undef,
	);

my $res = GetOptions( \%options,
					  keys(%optional_options) );

exit unless $res;
common_options::setup( \%options, 'update_inits' ); #calls set_globals etc, initiates random sequence, sets nm_version
#print "seed ".$options{'seed'}."\n";
#print "nm_vesrion ".$options{'nm_version'}."\n";

my %help_text;

$help_text{Pre_help_message} = <<'EOF';
    Update a model file with final estimates from NONMEM output.
EOF

$help_text{Post_help_message} = <<'EOF';
EOF

$help_text{Description} = <<'EOF';
The final estimates will either be taken from an lst-file given explicitly as the second 
command-line argument after the model file name, from another model file given with option -from\_model, 
or from the lst-file with the same file stem as the model file.
EOF

$help_text{Examples} = <<'EOF';
update_inits run1.mod run1abc.lst -output_model=run2.mod

Update a copy of run1.mod with estimates from run1abc.lst.

update_inits run22.mod -out=run23.mod

Update a copy of run22.mod and call the new file run23.mod. This requires that run22.lst exists.

update_inits run33.mod

Modify file run33.mod and copy original to run33.mod.org. This requires that run33.lst exists.

update run3.mod -from_model=run4.mod -out=run6.mod

Use parameters estimates from a model file instead of a lst-file.
EOF

$help_text{Options} = <<'EOF';
A modelfile to update must be specified.

The following options are valid:
EOF

$help_text{-h} = <<'EOF';
-h | -?

    With -h or -? the script prints the list of available options 
    and exit.
EOF

$help_text{-help} = <<'EOF';
-help

    With -help a longer help message will be printed.
EOF

$help_text{-output_model} = <<'EOF';
-output_model=file

    The name of the model file to create. If this options is omitted, a copy of
	the original model file with extension .org is created, and the original 
	file is modified.
EOF

$help_text{-ignore_missing_parameters} = <<'EOF';
-ignore_missing_parameters

	Default not set
	
	If set, update_inits will not require a 1-to-1 matching of parameter names 
	and indexes between the model to update and the source 	of new estimates 
	(lst-file or other model file).
EOF

$help_text{-update_fix} = <<'EOF';
-update_fix

	Default not set
	
	If set, update_inits will update parameters that are FIX in the model. The
	default is to not update parameters that are fixed.
EOF

$help_text{-fix_thetas} = <<'EOF';
-fix_thetas

	Default not set
 	
	If set, update_inits will set all THETAs that are not part of a prior to FIX.
EOF

$help_text{-unfix_thetas} = <<'EOF';
-unfix_thetas

	Default not set

	If set, update_inits will remove FIX, if present, from all THETAs that are not part of a prior.
EOF

$help_text{-from_model} = <<'EOF';
-from_model=filename

	Default not used

    The name of a model file to copy initial estimates from, instead of a lst-file. 
	Cannot be used together with a named lst-file on the command-line.
EOF

$help_text{-comment} = <<'EOF';
-comment=text

    Default not used.

	If the option is used, a new line with <text> will be inserted 
	directly following the $PROBLEM row.
	The comment text must be enclosed with quotes (double quotes on Windows) 
	if it contains spaces.
EOF

$help_text{-degree} = <<'EOF';
-degree=fraction

    Default not set

    After updating the initial estimates in the output file, randomly
	perturb them by degree=fraction, i.e. change estimate to a value
	randomly chosen in the range estimate +/- estimate*fraction while
	respecting upper and lower boundaries, if set in the model file.
	Degree is set to 0.1, a 10% perturbation, when option tweak_inits is set in execute.
EOF

$help_text{-add_tags} = <<'EOF';
-add_tags

    Default not set

    Add all runrecord tags, see runrecord user guide. update_inits will not check if any tags 
	are already present.
EOF

$help_text{-flip_comments} = <<'EOF';
-flip_comments

    Default not set

	Between each tag line
	;Sim_start
	and
	;Sim_end
    remove the first ; on each line that has ; as the first non-blank
	character, and prepend with ; at each line that does not
	have a ; as the first non-blank character.
	This processing will be done as the very first step, so lines
	that are commented out by this procedure will not be updated any more.
EOF

$help_text{-ensure_posdef} = <<'EOF';
-ensure_posdef

    Default not set

    NONMEM sometimes prints OMEGA or SIGMA matrices
	in the lst-file which are not positive definite, and the 
	ensure_posdef option offers a way to fix this.
	If option is set then PsN will make a cholesky decomposition of
	each OMEGA and SIGMA block to check positive definiteness, and
	inflate the diagonal elements of the block with 5% in each iteration where the cholesky fails.
EOF

$help_text{-add_prior} = <<'EOF';
-add_prior=df1,df2,...

    Default not set

    Add $PRIOR NWPRI based on the NONMEM output. Will automatically read
	estimates and covariances from output and use them to define the 
	prior. df should be the degrees of freedom, a comma-separated list
	with one integer per omega block.
	This feature is highly experimental, and you must check $PRIOR 
	in the new model file manually before using it.
	Option -add_prior cannot be used together with option -from_model. 
	Also note that the informative record names $THETAP, $THETAPV etc are used,
	so the resulting model can only be run with a NONMEM version that 
	supports this.
EOF

$help_text{-nm_version} = <<'EOF';
    -nm_version='string'
Default is 'default'. The formatting of the initial estimates will depend on the
major version number of NONMEM (e.g. 6 or 7) set in psn.conf for the
NM version chosen.
EOF

$help_text{-seed} = <<'EOF';
-seed=some string

    The random seed for perturbation if option -degree is set. 
EOF

$help_text{-based_on} = <<'EOF';
 -based_on=number

    If the -based_on option is used, update_inits will set 
	the runrecord 'Based on' tag (if present, or if option -add_tags is used) 
	to that number. If option -based_on is not used, update_inits will by default try to extract 
	a run number from the original model file name and use that instead in the tag.
	If a number cannot be extracted then nothing will be set. 
EOF

$help_text{-renumber} = <<'EOF';
-renumber='new number'

    Default extracted from the -output_model file name.	If -output_model=runY.mod 
	is set where Y is a number then -renumber=Y will be set automatically.
	Provided that 'new number' is not 0,
	the FILE option of all $TABLE will get <any number up to optional dot> 
	replaced with <new number>,
	the MSFO option of all $ESTIMATION will get <any number up to optional dot> 
	replaced with <new number>,
	and $MSFI filename of second and later $PROB will get 
	<any number up to optional dot> replaced with <new number>

	Set option -renumber=0 to prevent automatic renumbering in $TABLE and $EST and $MSFI.
EOF


common_options::online_help('update_inits', \%options, \%help_text, \%required_options, \%optional_options);

if ( scalar( @ARGV ) < 1 ){
  print "A model file must be specified. Use 'update_inits -h' for help.\n";
  exit;
}

my $ignore_missing_parameters=0;
if ( defined $options{'ignore_missing_parameters'} ){
	$ignore_missing_parameters=1;
}
my $update_fix=0;
if ( defined $options{'update_fix'} ){
	$update_fix=1;
}


unless( $ARGV[0] ){
	die "You must at least enter a model file name\n";
}
unless( -e $ARGV[0] ){
	die "No such file: $ARGV[0]\n";
}

my $input_run_number;
$input_run_number = model::get_run_number_string(filename => $ARGV[0]) if ($ARGV[0]);

my $output_run_number;
my $auto_renumber=0;
if (defined $options{'renumber'}) {
	$output_run_number=$options{'renumber'} if ($options{'renumber'} != 0);
}elsif( $options{'output_model'} ){
	$output_run_number = model::get_run_number_string(filename => $options{'output_model'});
	if (defined $output_run_number){
		$options{'renumber'}=$output_run_number;
		$auto_renumber=1;
	}  
}


if( $ARGV[1] && $options{'from_model'}){
	die "Ambiguous input: Cannot specify both lst-file and from_model.\n";
}

if( $options{'add_prior'})  {
	push(@record_list,'PRI');
	die "Cannot specify both -add_prior and -from_model.\n" if($options{'from_model'});
}



my $ignore_missing_files=1;
$ignore_missing_files = 0 unless ( $ARGV[1] );
my $model = model -> new ( filename => $ARGV[0],
						   ignore_missing_files => $ignore_missing_files,
						   ignore_missing_data =>1);

my $model_copy;

if ($options{'flip_comments'}){
	#flip_comments must be done as very first step, because later processing might
	#add or modify records so that tags do not do the right thing anymore
	$model_copy = model::flip_comments(from_model =>$model,
									   new_file_name => $ARGV[0].'.flipped',
									   write => 0);

}else{
	$model_copy = model -> new ( filename => $ARGV[0],
								 ignore_missing_output_files => 1,
								 ignore_missing_data=>1);
}

my $mismatch = $model_copy->msfo_to_msfi_mismatch;
if ($mismatch){
	ui->print(category => 'all',
			  message => "Warning: \$MSFI of \$PROBLEM number $mismatch in ".$ARGV[0].
			  " does not match previous \$EST MSFO. Check results carefully.\n");
}

my $outfile;
my $output;

if ( $options{'output_model'} ){
	$outfile = $options{'output_model'};
}  else {
	#original file will be overwritten, copy to .org
	cp( $ARGV[0], $ARGV[0].'.org' );
	unlink($ARGV[0]);
	$outfile = $ARGV[0];
}

if (defined $options{'from_model'}) {
	die "No such file: ".$options{'from_model'}."\n" unless (-e $options{'from_model'});
	my $params_model = model -> new ( filename => $options{'from_model'},
									  ignore_missing_files => 1,
									  ignore_missing_data=>1);

	my $array = $params_model->get_hash_values_to_labels();
	if (scalar(@{$model_copy->problems}) > scalar(@{$array})){
		ui->print(category => 'all',
				  message => "\n".'from_model has fewer $PROBLEM than '.$ARGV[0].
				  ". Will not update initial estimates in more than ".
				  scalar(@{$array}).' $PROBLEM:s');
	}elsif (scalar(@{$model_copy->problems}) < scalar(@{$array})){
		ui->print(category => 'all',
				  message => "\n".'from_model has more $PROBLEM than '.$ARGV[0].
				  ". Will not update initial estimates in more than ".
				  scalar(@{$model_copy->problems}).' $PROBLEM:s');
	}

	my $check = 0;
	$check = $options{'ensure_posdef'} if (defined $options{'ensure_posdef'});
	for (my $i=0; $i< scalar(@{$model_copy->problems}); $i++){
		if ($i >= scalar(@{$array})){
			last;
		}
		$model_copy -> update_inits( from_hash => $array->[$i],
									 problem_number => ($i+1),
									 ensure_posdef => $check,
									 ignore_missing_parameters => $ignore_missing_parameters,
									 update_fix => $update_fix);
	}

} else { 
	if( $ARGV[1] ){
		$output = output -> new( filename => $ARGV[1],
								 ignore_missing_files => 0);

		unless( $output ){
			die "No such file: $ARGV[1]\n";
		}
		unless ($output->parsed_successfully()){
			die "Failed to parse $ARGV[1]: ".$output -> parsing_error_message();
		}
	}elsif( defined $model->outputs and -e $model ->outputs -> [0] -> filename ){
		$output = $model -> outputs -> [0];
		unless ($output->parsed_successfully()){
			die "Failed to parse ".$model ->outputs -> [0] -> filename.": ".
				$output -> parsing_error_message();
		}
	} else {
		die "No file to read parameter values from\n";
	}

	if (scalar (@{$model_copy->problems})>1){
		ui->print(category => 'all',
				  message => $ARGV[0].
				  ' has more than one $PROBLEM. Will update naively $PROB by $PROB from lst-file');

	}

	my $check = 0;
	$check = $options{'ensure_posdef'} if (defined $options{'ensure_posdef'});
	$model_copy -> update_inits( from_output => $output,
								 ensure_posdef => $check,
								 ignore_missing_parameters => $ignore_missing_parameters,
									 update_fix => $update_fix );

}
$model_copy -> filename( $outfile );

my @record_list=('THETA','OMEGA','SIGMA');
print "Updating records ".join(' ',@record_list)."\n";

if (defined $options{'degree'}){
	foreach my $prob ( @{$model_copy->problems()}) {
		$prob -> set_random_inits ( degree => $options{'degree'} );
	}
}


if ($options{'fix_thetas'}){
	for (my $j=0; $j< scalar(@{$model_copy->problems}); $j++){
		next unless (defined $model_copy ->problems()->[$j]->thetas());
		foreach my $rec (@{$model_copy ->problems()->[$j]->thetas()}){
			next if $rec->prior();
			foreach my $opt (@{$rec->options()}){
				$opt->fix(1);
			}
		}
	}
}
if ($options{'unfix_thetas'}){
	for (my $j=0; $j< scalar(@{$model_copy->problems}); $j++){
		next unless (defined $model_copy ->problems()->[$j]->thetas());
		foreach my $rec (@{$model_copy ->problems()->[$j]->thetas()}){
			next if $rec->prior();
			foreach my $opt (@{$rec->options()}){
				$opt->fix(0);
			}
		}
	}
}


if ($options{'add_prior'}){
	$model_copy -> problems()->[0]->add_prior_distribution(from_output => $output,
														   problem_number => 1,
														   df_string => $options{'add_prior'});
}	

if (defined $options{'renumber'} and $options{'renumber'} != 0){
	my @probtab=();
	my @probmsfo=();
	my @probmsfi=();
	for (my $j=0; $j< scalar(@{$model_copy->problems}); $j++){
		#handle table
		if (defined $model_copy->problems->[$j]->tables){
			push (@probtab,($j+1));
			foreach my $tab (@{$model_copy->problems->[$j]->tables}){
				$tab->renumber_file (numberstring => $output_run_number);
			}
		}
		#handle estimation
		if (defined $model_copy->problems->[$j]->estimations){
			push (@probmsfo,($j+1)) if $model_copy->is_option_set(problem_number => ($j+1),
																  record => 'estimation',
																  name => 'MSFO',
																  fuzzy_match => 1);
			foreach my $est (@{$model_copy->problems->[$j]->estimations}){
				$est->renumber_msfo (numberstring => $output_run_number);
			}
		}
		#handle msfi
		if ($j > 0){
			#if second or higher $PROB we assume we want msfi from previous $PROB
			if (defined $model_copy->problems->[$j]->msfis){
				push (@probmsfi,($j+1));
				foreach my $msfi (@{$model_copy->problems->[$j]->msfis}){
					$msfi->renumber_msfi (numberstring => $output_run_number);
				}
			}
		}
	}
	if (scalar(@probtab)+scalar(@probmsfo)+scalar(@probmsfi)){
		$message = 'and renumbering ';
		if(scalar(@probtab) > 0){
			$message .= '$TABLE FILE= in $PROB '.join(',',@probtab)."\n";
		}
		if(scalar(@probmsfo) > 0){
			$message .= '$EST MSFO= in $PROB '.join(',',@probmsfo)."\n";
		}
		if(scalar(@probmsfi) > 0){
			$message .= '$MSFI <file> in $PROB '.join(',',@probmsfi)."\n";
		}
		print $message;
	}

}

#handle PROBLEM update_tags add_tags add_comment
if ($options{'add_tags'}) {
    $model_copy->annotation->add_empty_tags();
}

my $based_on = $input_run_number;
$based_on = $options{'based_on'} if (defined $options{'based_on'});
if (defined $based_on) {
    $model_copy->annotation->set_based_on($based_on);
}

if (defined $options{'comment'}) {
	$model_copy->problems->[0]->problems->[0]->add_comment(new_comment => $options{'comment'});
}

$model_copy->_write(number_format => $options{'sigdig'});
