#!/usr/bin/perl

# Only for Development
use FindBin qw($Bin);
use lib "$Bin/../lib";

# Don't edit the line below, it must look exactly like this.
# Everything above this line will be replaced #

# Perl includes #
use Config;
use strict;
use Getopt::Long;
# External modules #
use Math::Random;
# PsN includes #
use PsN;
use common_options;
use ui;
use Cwd;
use File::Copy qw/cp mv/;
use File::Glob;
use File::Path 'rmtree';
use tool;
use linear_algebra;
use array qw(quantile);
use MooseX::Params::Validate;
# More PsN dependencies included with require further down

#FIXME these should be options or read from file
my $minimum = 50; #change to 1000 later
my @covnames = (); #from model, first lines in FREM CODE BEGIN BSV_covname =
my @parnames = ();
my @tvpar = ();
my @cov_means = (); #ncov last THETA fix from model
my @cov_reference = ();
my @cov_rescale = ();
my @cov_units=();
my @categorical =();
my %categorytext=();
my %categorydiff=();
#TODO parse out scaling from model
if (1){
	#Hamren
	@covnames=('AGE','WGT','LBW','CRCO','SEX'); #Hamren linearized
	@cov_units=('years','kg','kg','ml/min','');
	@categorical=(0,0,0,0,1);
	$categorytext{'SEX'}=['male','female'];
	$categorydiff{'SEX'}=1; #other minus reference
	@parnames=('GAM','KINH','HB50','FPG_BASELINE','EC50_FPG','PBO_FPG'); #hamren linearized
	@tvpar=(0.743,
			1.05,
			8.25,
			8.2,
			1.48,
			0.164
		);
#$THETA  (0.4,0.743,1.5) ; 8 Exponent for FPG on HBA1C
#	IF(SEX.EQ.1) TKIN = THETA(12)/24                    ;12 Kin males
#IF(SEX.EQ.2) TKIN = THETA(20)/24                    ;20 kin females
 #              KINH = TKIN*EXP(ETA(2))               
#$THETA  (0.1,1.11,2) ; 12 KINH male
#$THETA  (0.1,1.02,2) ; 20 Kinh female
	#IF(SEX.EQ.2 or 1)  THB50 = THETA(15)*(1+THETA(21)*(AGE-55))
#$THETA  (0.01,8.25,20) ; 15 HB50 male
#$THETA  0 FIX ; 21 HB50 age	
#$THETA  (0.01,8.25,20) ; 15 HB50 male
	#$THETA  0 FIX ; 21 HB50 age
	#FPG baseline
#               BASE = THETA(1) * EXP(ETA(6))            ;1 BASELINE (start value at visit 1)
#$THETA  (6,8.2,10) ; 1 BASE FPG
#IF(PRET.EQ.1)  BASE = THETA(9) * EXP(ETA(6))            ;9 BASELINE for drug-naive patients
#IF(SEX.EQ.1)   EC50 = THETA(4)* EXP(ETA(7))             ;4 EC50 for males
#IF(SEX.EQ.2)   EC50 = THETA(4)*(1+THETA(7))*EXP(ETA(7)) ;7 EC50 for females
#$THETA  (0.2,1.48,4) ; 4 EC50 FPG
#$THETA  (0.01,0.164,1) ; 6 pbo effect FPG

	
	@cov_means=(57.1553398058,
				88.9502427184,
				58.4322815534,
				69.5191747573,
				1.41262135922 );
	@cov_reference = @cov_means;
	$cov_reference[4] = 1; #SEX, male
	@cov_rescale =(
		10.2318688078,
		17.738664519,
		11.2023916302,
		20.6542819724,
		0.492904320263);

}else{
	#moxpd
	@covnames=('AGE','WT','NEUY','CLCR','SEX','ACE','NYHA'); #mox_pd frem 11
	@parnames=('BASE','SLOPE'); #moxpd frem 11
	@cov_means =(65.5773195876,
				 78.4742268041,
				 2761.89690722,
				 67.6082474227,
				 1.24742268041,
				 0.59793814433,
				 2.54639175258);
	@cov_reference = @cov_means;
	$cov_reference[1] = 70; #WT
	$cov_reference[4] = 1; #SEX
	$cov_reference[5] = 1; #ACE
	$cov_reference[6] = 3; #NYHA
	@cov_rescale = (7.78330886624,
				   15.8482995825,
				   1815.19644532,
				   23.2031592232,
				   0.433756071885,
				   0.492861411691,
				   0.500429368907);
}
my @labels=(@parnames,@covnames);


#numbers from model, very beginning of PK/PRED BSV_x=ETA(n)*number
#npar 1 in beginning




#log-normal distribution of parameters !! Tv_par*exp(...)
my @par_divide_cv =();
@par_divide_cv =(1,
				 1
	);


my $cmd_line = $0 . " " . join( " ", @ARGV );

my %options;

my %required_options = ("model:s" => undef,
						'npar:i' => undef,
						'rawres_input:s' => undef,
						'frem_dataset:s' => undef,
	);
my %optional_options = ('offset_rawres:i' => undef,
			'in_filter:s' => undef,
	);

my $res = GetOptions( \%options,
					  @common_options::get_opt_strings,
					  keys(%required_options),
					  keys(%optional_options) );

exit unless $res;




my %help_text;

$help_text{Pre_help_message} = <<'EOF';
Postprocessing for frem
EOF
$help_text{Description} = <<'EOF';
   model plus raw_results from sir
EOF
$help_text{Options} = <<'EOF';

The following options are valid:
EOF
$help_text{Examples} = <<'EOF';
postfrem -model=model_4.mod rawres_input=raw_results_model_4.mod -in_filter=resamples.gt.0
EOF
$help_text{-rawres_input} = <<'EOF';
      -rawres_input=filename

      required. from sir. If have covmatrix from model 4 in frem can run sir
with -samples=1000, resamples=50 and then have no in_filter (just sample from covmatrix).
A bit slow since do MAXEVAL=0 for all samples and not use it for anything, but already implemented
so good enough for now. 
If use final output from sir then make sure use in_filter for resamples.

EOF
$help_text{-frem_dataset} = <<'EOF';
      -frem_dataset=filename

      required. from frem
EOF
$help_text{-offset_rawres} = <<'EOF';
      -offset_rawres=N

      Default is 1, i.e. first line is minimum. Do not set to 0.
EOF
$help_text{-model} = <<'EOF';
    -model
    Required. Model used as sir input.
EOF
$help_text{-npar} = <<'EOF';
    -npar
    Required. Number of parameter etas in last omega block. Then comes covars
EOF
$help_text{-in_filter} = <<'EOF';
      -in_filter=comma-separated list of conditions

    Default not used.
	If full sir run then set to resamples.gt.0, otherwise skip.
EOF

common_options::online_help('postfrem', \%options,\%help_text, \%required_options, \%optional_options);
common_options::setup( \%options, 'postfrem' ); #calls set_globals etc, initiates random sequence

require model;

## Set the automatic renaming of modelfit directory

my $main_directory = tool::get_rundir(create => 1,
				  basename => 'postfrem',
				  modelname => $options{'model'},
				  directory_option => $options{'directory'});

my @outputfiles;


my $eval_string = common_options::model_parameters(\%options);

if( scalar @ARGV > 0 ) {
  die "missing -optionsname?\n";
}
if( not defined $options{'model'})  {
  die "must set -model\n";
}

if( not defined $options{'rawres_input'})  {
  die "must set -rawres_input\n";
}
if( not defined $options{'frem_dataset'})  {
  die "must set -frem_dataset\n";
}
my $npar = $options{'npar'};


my $model = model -> new ( eval( $eval_string ),
			  filename                    => $options{'model'},
			  ignore_missing_output_files => 1 );
    
#TODO read covnames, cov_means, cov_rescale

sub read_covdata
{
    my %parm = validated_hash(\@_,
							  covnames => { isa => 'ArrayRef', optional => 0 },
							  filename => { isa => 'Str', optional => 0 },
							  dv => { isa => 'Str', default => 'DV' },
	);
	my $covnames = $parm{'covnames'};
	my $filename = $parm{'filename'};
	my $dv = $parm{'dv'};

	my %fremtype_to_cov=();
	my %cov_arrays=();
	my %id_arrays=();

	
	for (my $i=0; $i< scalar(@{$covnames}); $i++){
		my $fremtype = ($i+1)*100;
		$fremtype_to_cov{$fremtype}=$covnames->[$i];
		$cov_arrays{$covnames->[$i]} = [];
	}
	
    open my $fh, '<', $filename;
	my $frem_index=-1;
	my $dv_index=-1;
	my $id_index=-1;
    my $header_row = <$fh>;
	chomp($header_row);
	my @fields = split(',',$header_row);
	for (my $i=0; $i< scalar(@fields); $i++){
		if($fields[$i] eq $dv){
			$dv_index = $i;
		}elsif($fields[$i] eq 'FREMTYPE'){
			$frem_index = $i;
		}elsif($fields[$i] eq 'ID'){
			$id_index = $i;
		}
		last if (($frem_index >= 0) and ($dv_index >=0) and ($id_index >=0));
	}
	croak("could not find DV and FREMTYPE and ID") unless (($frem_index >= 0) and ($dv_index >=0) and ($id_index >=0));
	my $row; 
	while (1) {
		$row = <$fh>;
		last unless (defined $row);
		chomp ($row);
		@fields = split(',',$row);
		if ($fields[$frem_index] > 0){
			my $cov = $fremtype_to_cov{$fields[$frem_index]};
			push(@{$cov_arrays{$cov}},$fields[$dv_index]);
			my $id = $fields[$id_index];
			unless (exists $id_arrays{$id}){
				$id_arrays{$id}={};
			}
			if (exists $id_arrays{$id}->{$cov}){
				croak("redefinition of $cov for id $id");
			}else{
				$id_arrays{$id}->{$cov} = $fields[$dv_index];
			}
		}
	}
	close $fh;
	for (my $i=1; $i< scalar(@{$covnames}); $i++){
		unless (scalar(@{$cov_arrays{$covnames->[$i]}}) == scalar(@{$cov_arrays{$covnames->[$i-1]}})){
			croak("unequal length $i and $i-1");
		}
		unless (scalar(@{$cov_arrays{$covnames->[$i]}}) > 0){
			croak("legth $i not larger than 0");
		}
	}

	my @id_covariate_vectors = ();
	foreach my $idnum (sort {$a <=> $b} keys %id_arrays){
		push(@id_covariate_vectors,[$idnum]);
		for (my $i=0; $i< scalar(@{$covnames}); $i++){
			if (defined $id_arrays{$idnum}->{$covnames->[$i]}){
				push(@{$id_covariate_vectors[-1]},$id_arrays{$idnum}->{$covnames->[$i]});
			}else{
				croak("id $idnum undefined covariate ".$covnames->[$i]);
			}
		}
	}
	
	my @perc_5th=();
	my @perc_95th=();
	for (my $i=0; $i< scalar(@{$covnames}); $i++){
		my @sorted = (sort {$a <=> $b} @{$cov_arrays{$covnames->[$i]}}); #sort ascending
		my $quantref = array::quantile(probs => [0.05,0.95], numbers=> \@sorted);
		push(@perc_5th,$quantref->[0]);
		push(@perc_95th,$quantref->[1]);
	}

	return(\@perc_5th,\@perc_95th,\@id_covariate_vectors);
}

my ($cov_5th,$cov_95th,$id_covariate_vectors) = read_covdata(covnames => \@covnames,
															 filename => $options{'frem_dataset'});




my $sampled_params_arr;
my $href;
my $samples;
my $offset=1;
$offset= $options{'offset_rawres'} if (defined $options{'offset_rawres'});
my @in_filter=();
if ( defined $options{'in_filter'} ){
	#split string, assume comma separated
	foreach my $filt (split(/,/,$options{'in_filter'})){
		if ($filt =~ /.\.(gt|lt|eq)\.\d+\.?\d*/){
			push(@in_filter,$filt);
		}else{
			die "Input filter $filt does not fulfill the format rules.\n";
		}
	}
	if (scalar(@in_filter)<1){
		die "Error: Option in_filter used, but list of conditions could not be parsed.\n";
	}	
}

($sampled_params_arr,$href) = model::get_rawres_params(filename => $options{'rawres_input'},
						   filter => \@in_filter,
						   offset => $offset,
						   model => $model);

if (defined $sampled_params_arr) {
	unless (scalar(@{$sampled_params_arr}) >= $minimum) {
		if (defined $options{'in_filter'}) {
		 croak("Too few sets (lines) of parameter values in\n".
				 "rawres file after filtering. Have ".
		scalar(@{$sampled_params_arr})." but need at least $minimum\n");
		} else {
			croak("Too few sets (lines) of parameter values in\n".
			  "rawres file. Have ".scalar(@{$sampled_params_arr}).
			  " but need at least $minimum plus offset\n");
		}
	}
}else{
   croak("get_rawres_params returned undef");
}


my ($center_params_arr,$href2) = model::get_rawres_params(filename => $options{'rawres_input'},
						   filter => [],
						   offset => 0,
						   model => $model);


chdir($main_directory); #created by tool::get_rundir



my $omegaindex = scalar(@{$model->problems->[0]->omegas})-1;
my $size = $model->problems->[0]->omegas->[$omegaindex]->size;
my $npar = $options{'npar'};
unless (defined $npar and ($npar < $size) and ($npar == scalar(@parnames))){
	croak("npar $npar is not defined and smaller than size $size");
}

my $index=0;
unless (scalar(@labels)==$size){
	croak("size is $size but label count is ".scalar(@labels));
}
#for (my $i=0;$i<$size; $i++){
#	$varheader .= ',STDEV.'.$labels[$i];
#}
#for (my $i=0;$i<$size; $i++){
#	for (my $j=0;$j<$i; $j++){
#		$header .= ',CORREL.'.$labels[$i].'.'.$labels[$j];
#	}
#}
#for (my $i=0;$i<$npar; $i++){
#	for (my $j=$npar;$j<$size; $j++){
#		$header .= ',COEFF.par.'.$labels[$i].'.cov.'.$labels[$j];
#	}
#}

my $id_count = scalar(@{$id_covariate_vectors});

my %coeff_arrays=();
my %variance_arrays=();
my %id_ratio_arrays=();
foreach my $par (@parnames){
	$id_ratio_arrays{$par}={};
	$coeff_arrays{$par}={};
	$coeff_arrays{$par}->{'all'} = [];
	$variance_arrays{$par}={};
	$variance_arrays{$par}->{'none'} = [];
	$variance_arrays{$par}->{'all'} = [];
	foreach my $cov (@covnames){
		$coeff_arrays{$par}->{$cov} = [];
		$variance_arrays{$par}->{$cov} = [];
	}
	for (my $l=0; $l< $id_count; $l++){
		#idnum
		$id_ratio_arrays{$par}->{$id_covariate_vectors->[$l]->[0]}=[];
	}
}





open (my $idfh, '>','id_covdata.csv') or die ("cannot open < id_covdata.csv: $!");
print $idfh 'ID,'.join(',',@covnames)."\n";
for (my $l=0; $l< $id_count; $l++){
	print $idfh join(',',@{$id_covariate_vectors->[$l]})."\n";
}
close $idfh;

open( FILE1, '>pardata.csv' );
print FILE1 'parname'."\n";
for (my $i=0; $i< scalar(@parnames); $i++){
	print FILE1 $parnames[$i]."\n";
}
close FILE1;

open( FILE2, '>covdata.csv' );
print FILE2 'covname,perc5th,mean,perc95th,reference,unit,category.reference,category.other'."\n";
for (my $i=0; $i< scalar(@covnames); $i++){
	my $string = $covnames[$i].','.$cov_5th->[$i].','.$cov_means[$i].','.$cov_95th->[$i].','.$cov_reference[$i].','.$cov_units[$i].',';
	if ($categorical[$i]){
		$string .= $categorytext{$covnames[$i]}->[0].','.$categorytext{$covnames[$i]}->[1];
	}else{
		$string .= ',';
	}
	print FILE2 $string."\n";
}
close FILE2;


	
my @rescale = (1) x $npar;
push(@rescale,@cov_rescale);
unless (scalar(@rescale)==$size){
	croak("length rescale is ".scalar(@rescale)." size is $size");
}

my $ratioheader='sample';
my $varheader='sample';


#1. none
#2. per cov
#3. all
for (my $i=0;$i<$npar; $i++){
	$varheader .= ',CONDVAR.par.'.$labels[$i].'.given.none';
}
for (my $j=$npar;$j<$size; $j++){
	for (my $i=0;$i<$npar; $i++){
		$varheader .= ',CONDVAR.par.'.$labels[$i].'.given.cov.'.$labels[$j];
	}
}
for (my $i=0;$i<$npar; $i++){
	$varheader .= ',CONDVAR.par.'.$labels[$i].'.given.allcov';
}



#1. per cov
#FIXME separate files all, given individual covariates
for (my $j=$npar;$j<$size; $j++){
	my $covindex  = $j-$npar;
	for (my $i=0;$i<$npar; $i++){
		if ($categorical[$covindex]){
#			$ratioheader .= ',RATIO.par.'.$labels[$i].'.given.reference.'.$labels[$j];
			$ratioheader .= ',RATIO.par.'.$labels[$i].'.given.other.'.$labels[$j];
		}else{
			$ratioheader .= ',RATIO.par.'.$labels[$i].'.given.cov5th.'.$labels[$j];
			$ratioheader .= ',RATIO.par.'.$labels[$i].'.given.cov95th.'.$labels[$j];
		}
	}
}


open( RATIOFILE, '>frem_ratio.csv' );
print RATIOFILE "$ratioheader\n";
open( VARFILE, '>frem_condvar.csv' );
print VARFILE "$varheader\n";

for (my $k=0;$k<=scalar(@{$sampled_params_arr}); $k++){
	if ($k==0){
	#center
		$model -> update_inits(from_hash => $center_params_arr->[0]);		
	}else{
		$model -> update_inits(from_hash => $sampled_params_arr->[$k-1]);
	}
	my $varcov = $model->problems->[0]->omegas->[$omegaindex]->get_matrix;
	my $error;
	#my $sdcorr=[]; 
	#my $error =linear_algebra::covar2sdcorr($varcov,$sdcorr);
	#croak("numerr index $k ") unless ($error == 0); 
	
	my $ratiovec = "$k";
	my $variancevec = "$k";
	for (my $i=0;$i<$npar; $i++){
		#		$varheader .= ',CONDVAR.par.'.$labels[$i].'.given.none';
		$variancevec .= ','.$varcov->[$i]->[$i];
		push(@{$variance_arrays{$labels[$i]}->{'none'}},$varcov->[$i]->[$i]);
	}
	my ($error,$cond_covar,$coeff);
	for (my $j=$npar;$j<$size; $j++){ #foreach covariate
		($error,$cond_covar,$coeff) = linear_algebra::conditional_covariance_coefficients(varcov => $varcov,
																						  rescaling => \@rescale,
																						  cov_index_first => $j,
																						  cov_index_last => $j,
																						  par_index_first => 0,
																						  par_index_last => ($npar-1));
		croak("cond covar coeff failed") if ($error != 0);
		my $covindex  = $j-$npar;
		for (my $i=0;$i<$npar; $i++){
			if ($categorical[$covindex]){
#				$ratioheader .= ',RATIO.par.'.$labels[$i].'.given.other.'.$labels[$j];
#				$ratiovec .= ',1';
				$ratiovec .= ','.exp(($categorydiff{$labels[$j]})*($coeff->[$i]->[0]));
			}else{
			#		$ratioheader .= ',RATIO.par.'.$labels[$i].'.given.cov5th.'.$labels[$j];
			#		$ratioheader .= ',RATIO.par.'.$labels[$i].'.given.cov95th.'.$labels[$j];
				$ratiovec .= ','.exp(($cov_5th->[$covindex]-$cov_means[$covindex])*($coeff->[$i]->[0]));
				$ratiovec .= ','.exp(($cov_95th->[$covindex]-$cov_means[$covindex])*($coeff->[$i]->[0]));
			}
			#		$varheader .= ',CONDVAR.par.'.$labels[$i].'.given.cov.'.$labels[$j];
			$variancevec .= ','.$cond_covar->[$i]->[$i];
			push(@{$variance_arrays{$labels[$i]}->{$labels[$j]}},$cond_covar->[$i]->[$i]);
			push(@{$coeff_arrays{$labels[$i]}->{$labels[$j]}},$coeff->[$i]->[0]);
		}
	}
	#all covariates
	($error,$cond_covar,$coeff) = linear_algebra::conditional_covariance_coefficients(varcov => $varcov,
																					  rescaling => \@rescale,
																					  cov_index_first => $npar,
																					  cov_index_last => ($size-1),
																					  par_index_first => 0,
																					  par_index_last => ($npar-1));
	croak("cond covar coeff failed") if ($error != 0);
	for (my $i=0;$i<$npar; $i++){
		#	$varheader .= ',CONDVAR.par.'.$labels[$i].'.given.allcov';
		$variancevec .= ','.$cond_covar->[$i]->[$i];
		push(@{$variance_arrays{$labels[$i]}->{'all'}},$cond_covar->[$i]->[$i]);
		push(@{$coeff_arrays{$labels[$i]}->{'all'}},join(',',@{$coeff->[$i]})); # a string

#		my $idvec = "$k";
		for (my $l=0; $l<$id_count; $l++){
			#	$idheader .= ',RATIO.id.'.$id_covariate_vectors->[$l]->[0];
			my $num=0;
			for (my $j=0;$j<($size-$npar); $j++){ #foreach covariate
				$num += ($id_covariate_vectors->[$l]->[$j+1]-$cov_reference[$j] )*($coeff->[$i]->[$j]);
			}
#			$idvec .= ','.exp($num);
			push(@{$id_ratio_arrays{$labels[$i]}->{$id_covariate_vectors->[$l]->[0]}},exp($num));
		}

#		print {$parameter_filehandles[$i]} "$idvec\n";
	}

#	for (my $i=0;$i<$size; $i++){
#		$numvec .= ','.($rescale[$i])*($sdcorr->[$i]->[$i]);   #',STDEV.'$lab;
#	}
#	for (my $i=0;$i<$size; $i++){
#		for (my $j=0;$j<$i; $j++){
#			$numvec .= ','.$sdcorr->[$i]->[$j];  #',CORREL.'.$labels[$i].'.'.$labels[$j];
#		}
#	}
	#covariate coefficients
#	for (my $i=0;$i<$npar; $i++){
#		for (my $j=$npar;$j<$size; $j++){
#			# cov(par,cov)/var(cov) plus rescale
#			$numvec .= ','.($varcov->[$i]->[$j])/(($rescale[$j])*($varcov->[$j]->[$j]));
			#',COEFF.par.'.$labels[$i].'.cov.'.$labels[$j];
#		}
#	}

	

#my ($cov_5th,$cov_95th)
	
	print RATIOFILE "$ratiovec\n";
	print VARFILE "$variancevec\n";
#	push(@sdcorr_array,$numvec);
#	last; 
}
close( RATIOFILE );
close( VARFILE );

my @probs = (0.05,0.10,0.5,0.90,0.95);
my $header = 'ID';

for (my $i=0;$i<$npar; $i++){
	$header .= ','.$parnames[$i].'.observed';
	for (my $l=0; $l<scalar(@probs); $l++){
		$header .= ','.$parnames[$i].'.'.($probs[$l]*100).'th';
	}
}
my $name = 'frem_id_ratios.csv';
my $parfh;
open($parfh,'>',$name) or die "cannot open < $name: $!";
print {$parfh} "$header\n";

for (my $l=0; $l<$id_count; $l++){
	#	$header .= ',RATIO.id.'.$id_covariate_vectors->[$l]->[0];
	#push(@{$id_ratio_arrays{$par}->{$id_covariate_vectors->[$l]->[0]}},exp($num));
	my $idnum = $id_covariate_vectors->[$l]->[0];
	my $idline = $idnum;
	for (my $i=0;$i<$npar; $i++){
		my $par = $labels[$i];
		my $observed = shift(@{$id_ratio_arrays{$par}->{$idnum}});
		$idline .= ','.$observed;
		my @sorted = (sort {$a <=> $b} @{$id_ratio_arrays{$par}->{$idnum}}); #sort ascending
		my $quantref = quantile(probs => \@probs, numbers=> \@sorted);
		for (my $k=0; $k< scalar(@probs); $k++){
			$idline .= ','.$quantref->[$k];
		}
	}
	print {$parfh} "$idline\n";
}
close($parfh);


#wikipedia: SD(x) lognormal with mu 0 and sigma :
#exp(0.5*sigma^2)*sqrt(exp(sigma^2)-1)
#estimate is $tvpar[$i]

sub get_cv{
	my $var=shift;
	my $est = shift;
	return 100*(exp(0.5*$var)*sqrt(exp($var)-1))/$est; #SD/est
#	return 100*(exp($var)*(exp($var)-1))/$est; #variance over est
}


@probs = (0.05,0.95);
$header = 'par.conditionedOn,observed.var,var.5th,var.95th,observed.cv.perc,cv.5th,cv.95th';
foreach my $cov (@covnames){
	$header .= ',coeff.'.$cov;
}
$name = 'variance_coefficients_summary.csv';
$parfh;
open($parfh,'>',$name) or die "cannot open < $name: $!";
print {$parfh} "$header\n";
my @types =('none',@covnames,'all');
for (my $i=0;$i<$npar; $i++){
	my $par = $labels[$i];
	for (my $k=0; $k<scalar(@types); $k++){
		my $type = $types[$k];
		my $observed = shift(@{$variance_arrays{$par}->{$type}});
		my $line = $par.'.'.$type.','.$observed;
		my @sorted = (sort {$a <=> $b} @{$variance_arrays{$par}->{$type}});
		my $quantref = quantile(probs => \@probs, numbers=> \@sorted);
		$line .= ','.$quantref->[0];
		$line .= ','.$quantref->[1];
		$line .= ','.get_cv($observed,$tvpar[$i]);
		$line .= ','.get_cv($quantref->[0],$tvpar[$i]);
		$line .= ','.get_cv($quantref->[1],$tvpar[$i]);

		if ($type eq 'none'){
			$line .= ',' x scalar(@covnames); 
		}elsif($type eq 'all'){
			#				push(@{$coeff_arrays{$labels[$i]}->{'all'}},join(',',@{$coeff->[$i]})); # a string
			$line .= ','.$coeff_arrays{$par}->{'all'}->[0];
		}else{
			$line .= ','x $k ; #1 or more
			$line .= $coeff_arrays{$par}->{$type}->[0];
			$line .= ','x (scalar(@covnames)-$k) ;
		}
			
		print {$parfh} "$line\n";
	}
}
close($parfh);

